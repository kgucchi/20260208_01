/**
 * PR Agent
 * ç”Ÿæˆã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã‚’GitHubã«ã‚³ãƒŸãƒƒãƒˆã—ã¦PRã‚’ä½œæˆã™ã‚‹
 */

import { Octokit } from '@octokit/rest';
import type { GeneratedCode } from './codegen-agent.js';

export class PRAgent {
  private octokit: Octokit;
  private owner: string;
  private repo: string;

  constructor(token: string, repository: string) {
    this.octokit = new Octokit({ auth: token });
    const [owner, repo] = repository.split('/');
    this.owner = owner;
    this.repo = repo;
  }

  async createPR(
    issueNumber: number,
    generatedCode: GeneratedCode,
    issueTitle: string
  ): Promise<string> {
    console.log(`ğŸ“¤ Creating PR for issue #${issueNumber}...`);

    // 1. mainãƒ–ãƒ©ãƒ³ãƒã®æœ€æ–°ã‚³ãƒŸãƒƒãƒˆã‚’å–å¾—
    const { data: ref } = await this.octokit.git.getRef({
      owner: this.owner,
      repo: this.repo,
      ref: 'heads/main',
    });

    const baseSha = ref.object.sha;

    // 2. æ–°ã—ã„ãƒ–ãƒ©ãƒ³ãƒã‚’ä½œæˆ
    const branchName = `feature/issue-${issueNumber}-${Date.now()}`;
    await this.octokit.git.createRef({
      owner: this.owner,
      repo: this.repo,
      ref: `refs/heads/${branchName}`,
      sha: baseSha,
    });

    console.log(`ğŸ“ Created branch: ${branchName}`);

    // 3. ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚³ãƒŸãƒƒãƒˆ
    for (const file of generatedCode.files) {
      await this.createOrUpdateFile(branchName, file.path, file.content);
    }

    // 4. PRã‚’ä½œæˆ
    const { data: pr } = await this.octokit.pulls.create({
      owner: this.owner,
      repo: this.repo,
      title: `feat: ${issueTitle}`,
      head: branchName,
      base: 'main',
      body: this.buildPRBody(issueNumber, generatedCode),
      draft: true,
    });

    console.log(`âœ… PR created: ${pr.html_url}`);
    return pr.html_url;
  }

  private async createOrUpdateFile(
    branch: string,
    path: string,
    content: string
  ): Promise<void> {
    try {
      // ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
      const { data: existingFile } = await this.octokit.repos.getContent({
        owner: this.owner,
        repo: this.repo,
        path,
        ref: branch,
      });

      // å­˜åœ¨ã™ã‚‹å ´åˆã¯æ›´æ–°
      if ('sha' in existingFile) {
        await this.octokit.repos.createOrUpdateFileContents({
          owner: this.owner,
          repo: this.repo,
          path,
          message: `chore: Update ${path}`,
          content: Buffer.from(content).toString('base64'),
          branch,
          sha: existingFile.sha,
        });
      }
    } catch (error: any) {
      if (error.status === 404) {
        // ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯æ–°è¦ä½œæˆ
        await this.octokit.repos.createOrUpdateFileContents({
          owner: this.owner,
          repo: this.repo,
          path,
          message: `feat: Add ${path}`,
          content: Buffer.from(content).toString('base64'),
          branch,
        });
      } else {
        throw error;
      }
    }
  }

  private buildPRBody(issueNumber: number, generatedCode: GeneratedCode): string {
    return `## ğŸ¤– Autonomous Agent Implementation

**Issue**: #${issueNumber}

### Summary
${generatedCode.summary}

### Generated Files
${generatedCode.files.map(f => `- \`${f.path}\``).join('\n')}

### Description
This PR was automatically generated by the Miyabi Autonomous Operations Agent system.

All code has been generated using Claude AI and follows TypeScript best practices with strict mode enabled.

### Checklist
- [x] Code generated by AI
- [x] TypeScript strict mode enabled
- [ ] Manual review required
- [ ] Tests to be added
- [ ] Ready for merge

---

Closes #${issueNumber}

ğŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>`;
  }
}
